#include <iostream>
#include <graphics.h>
#include <vector>

#define BEHAVIOR_TYPE_CNT 2
using namespace std;

constexpr auto swidth = 480;
constexpr auto sheight = 780;



class OBJECT {
public:
	//OBJECT() : img(), x(0), y(0), rect{ 0, 0, 0, 0 } {}
	OBJECT(IMAGE& image) : img(image), x(0), y(0), rect{ 0, 0, 0, 0 } {

	}
	OBJECT(IMAGE& image, IMAGE& reverse) : img(image), rimg(reverse), x(0), y(0), rect{ 0, 0, 0, 0 } {}
protected:
	IMAGE& img, rimg;
	RECT rect;
	int x, y;
};



class Enemy_OBJECT : public OBJECT {
public:
	Enemy_OBJECT(IMAGE& image) : OBJECT(image) {
		if (behavior_table.empty()) {
			behavior_table = { &Enemy_OBJECT::low_speed,&Enemy_OBJECT::high_speed };
		}
	}
	void do_behavior() {
		int cur_do = rand() % behavior_table.size();
		(this->*behavior_table[cur_do])();
	}
protected:
	static vector<void(Enemy_OBJECT::*)()> behavior_table;
	void low_speed() {
		y += 2;
	}
	void high_speed() {
		y += 4;
	}
};

class Enemy : public Enemy_OBJECT {
public:
	Enemy(IMAGE& image, IMAGE& rimage, int x) : Enemy_OBJECT(image) {

	}
	Enemy(IMAGE& image) : Enemy_OBJECT(image) {
		initEnemy();
	}
	bool show() {
		do_behavior();
		if (!isOut()) {
			putimage(x, y, &img);
			return false;
		}
		else return true;
	}

private:
	void initEnemy() {
		x = rand() % (swidth - img.getwidth());
		rect.left = x;
		rect.right = rect.left + img.getwidth();
		rect.top = -img.getheight();
		rect.bottom = 0;
	}
	bool isOut() {
		if (y >= sheight) return true;
		return false;
	}
};


bool pointInRect(int x, int y, RECT& r) {
	return r.left <= x && x <= r.right && r.top <= y && y <= r.bottom;
}

void Welcome() {
	LPCTSTR title = _T("飞机大战");
	LPCTSTR tplay = _T("开始游戏");
	LPCTSTR texit = _T("退出游戏");
	RECT tplayr, texitr;
	BeginBatchDraw();
	setbkcolor(WHITE);
	cleardevice();
	settextstyle(40, 0, _T("宋体"));
	settextcolor(BLACK);
	outtextxy(swidth / 2 - textwidth(title) / 2, sheight / 10, title);

	tplayr.left = swidth / 2 - textwidth(tplay) / 2;
	tplayr.right = tplayr.left + textwidth(tplay);
	tplayr.top = sheight / 5 * 3.5;
	tplayr.bottom = tplayr.top + textheight(tplay);

	texitr.left = swidth / 2 - textwidth(texit) / 2;
	texitr.right = texitr.left + textwidth(texit);
	texitr.top = sheight / 5 * 4;
	texitr.bottom = texitr.top + textheight(texit);

	outtextxy(tplayr.left, tplayr.top, tplay);
	outtextxy(texitr.left, texitr.top, texit);
	EndBatchDraw();
	while (true) {
		ExMessage mess;
		getmessage(&mess, EM_MOUSE);
		if (mess.lbutton) {
			if (pointInRect(mess.x, mess.y, tplayr)) {
				return;
			}
			else if (pointInRect(mess.x, mess.y, texitr)) {
				exit(0);
			}
		}
	}
}

// 背景，敌机，英雄，子弹



class BK : public OBJECT {
public:
	BK(IMAGE& image) :OBJECT(image) {
		y = -sheight;
	}

	void show() {
		if (y == 0) y = -sheight;
		y += 2;
		putimage(0, y, &img);
	}
};

class Hero :public OBJECT {
public:

	Hero(IMAGE& image, IMAGE& rimage) : OBJECT(image, rimage) {
		initRect();
	}
	Hero(IMAGE& image) : OBJECT(image, image) {}

	void show() {
		putimage(rect.left, rect.top, &rimg, SRCAND);
		putimage(rect.left, rect.top, &img, SRCPAINT);
	}
	void control() {
		ExMessage mess;
		if (peekmessage(&mess, EM_MOUSE)) {
			rect.left = mess.x - img.getwidth() / 2;
			rect.top = mess.y - img.getheight() / 2;
			rect.right = rect.left + img.getwidth();
			rect.bottom = rect.top + img.getheight();
		}
	}
private:
	void initRect() {
		rect.left = swidth / 2 + img.getwidth() / 2;
		rect.top = sheight - img.getheight() * 2;
		rect.right = rect.left + img.getwidth();
		rect.bottom = sheight;
	}
};


class Bullet : OBJECT {
public:
	Bullet(IMAGE& image, IMAGE& rimage, RECT& plane_position) : OBJECT(image), position(plane_position) {

	}
	Bullet(IMAGE& image, RECT& plane_position) : OBJECT(image), position(plane_position) {
		initBullet();
	}
	void show() {
		putimage(x, y, &img);
	}
private:
	RECT& position;
	void initBullet() {
		x = (position.left + position.right) / 2 - img.getwidth() / 2;
		y = (position.top + position.bottom) / 2 + img.getheight() / 2;
		rect.left = (position.left + position.right) / 2 - img.getwidth() / 2;
		rect.right = rect.left + img.getwidth();
		rect.top = (position.top + position.bottom) / 2 - img.getheight() / 2;
		rect.bottom = rect.top + img.getheight();
	}
};

void load_enemy_img(vector<IMAGE>& eimg) {
	loadimage(&eimg[0], _T("D:\\img\\enemy.png"));
	loadimage(&eimg[1], _T("D:\\img\\enemy_2.png"));
}

void add_new_enemy(vector<Enemy*>& es, vector<IMAGE>& eimg,clock_t& last_creat, clock_t& next_creat) {
	clock_t t = clock();

	if (es.size() < 5 && t - last_creat >= next_creat) {
		es.push_back(new Enemy(eimg[rand() % (eimg.size())]));
		cout << "创建了一个敌机,下一搜生成时间为:" << next_creat <<endl;
		last_creat = t;
		next_creat = rand()%1000 + 500;
		cout << "当前敌机数量"  << es.size() << endl;
	}
}

void for_enemy(vector<Enemy*>& es) {
	for (int i = 0; i < es.size();) {
		if (es[i]->show()) {
			es.erase(es.begin() + i);
			cout << "删除了一架敌机,编号：" << i << endl;
		}
		else {
			i++;
		}
	}
}

int cal_fps(DWORD& lastTime, int& frameCount, DWORD& secondTimer) {
	DWORD curTime = GetTickCount();
	DWORD deltaTime = curTime - lastTime;
	lastTime = curTime;
	secondTimer += deltaTime;
	frameCount++;

	if (secondTimer >= 1000) {
		int fps = frameCount;
		frameCount = 0, secondTimer = 0;
		return fps;
	}
	else return 0;
}



void show_fps(TCHAR(&fpsText)[20], int fps) {
	if (fps > 0) {
		settextcolor(BLACK);
		settextstyle(20, 0, _T("黑体"));
		_stprintf_s(fpsText, _T("FPS:%d"), fps);
	}
	outtextxy(10, 10, fpsText);
}

void ctrl_fps(int start_time) {
	clock_t running_time = clock() - start_time;
	if (16 - running_time >= 0) Sleep(16 - running_time);
	TCHAR fpsText[50];
	int FPS = 1000 / (clock() - start_time);
	_stprintf_s(fpsText, _T("FPS:%d"), FPS);
	settextstyle(20, 0, _T("黑体"));
	outtextxy(0, 0, fpsText);
}

bool Play() {
	setbkcolor(WHITE);
	cleardevice();
	bool is_play = true;

	IMAGE heroimg, rHeroimg, enemyimg, bkimg, bulletimg;
	loadimage(&heroimg, _T("D:\\img\\hero.png"), 70, 70);
	loadimage(&rHeroimg, _T("D:\\img\\rhero.png"), 70, 70);
	loadimage(&bkimg, _T("D:\\img\\bk.png"));
	loadimage(&bulletimg, _T("\\img\\favorites-fill.png"));

	BK bk = BK(bkimg);

	Hero hp = Hero(heroimg, rHeroimg);
	vector<Enemy*> es;
	vector<IMAGE> eimg(1);

	load_enemy_img(eimg);//预加载敌机贴图


	//Bullet bl = Bullet(&bulletimg);

	//fps相关代码
	DWORD lastTime = GetTickCount();
	TCHAR fpsText[20];
	DWORD secondTimer = 0;
	int frameCount = 0;

	clock_t start_time;

	clock_t last_creat = 0, next_creat = 100;
	while (is_play) {

		//fps = cal_fps(lastTime);

		start_time = clock();
		BeginBatchDraw();
		cleardevice();
		//绘制背景
		bk.show();

		//绘制敌机
		add_new_enemy(es, eimg,last_creat,next_creat);
		for_enemy(es);
		flushmessage();
		Sleep(10);


		//记录玩家控制
		hp.control();


		//绘制玩家飞机
		hp.show();

		show_fps(fpsText, cal_fps(lastTime, frameCount, secondTimer));
		//ctrl_fps(start_time);
		EndBatchDraw();
	}
	return true;
}

vector<void(Enemy_OBJECT::*)()> Enemy_OBJECT::behavior_table;

int main() {
	initgraph(swidth, sheight, EX_SHOWCONSOLE);
	bool is_live = true;
	srand(time(0));


	while (is_live)
	{
		Welcome();
		is_live = Play();
	}
	cin.get();
	return 0;
}